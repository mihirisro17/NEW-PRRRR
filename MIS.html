<script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    currentTheme: 'theme-vedas',
                    autoThemeEnabled: false,
                    currentTime: '',
                    sidebarCollapsed: false,
                    currentPage: 'home',
                    currentAppUrl: '',
                    alertPanelCollapsedUp: false,
                    alertPanelCollapsedLeft: false,
                    datasetSectionCollapsed: false,
                    serverSectionCollapsed: false,
                    processSectionCollapsed: false,
                    storageSectionCollapsed: false,
                    datasetAlerts: [],
                    serverAlerts: [],
                    processAlerts: [],
                    storageAlerts: [],
                    clearedAlerts: new Set(),
                    lastUpdated: '',
                    storageLastModified: null,
                    lastStorageFetch: null, // Track last storage fetch time
                    totalServers: 20,
                    totalServices: 41,
                    isLoading: false,
                    isRefreshing: false,
                    showHistory: false,
                    alertHistory: [],
                    showBreakNotification: false,
                    breakNotification: {},
                    breakAutoCloseSeconds: 30,
                    breakAutoCloseInterval: null,
                    shownBreakTimes: new Set(),
                    monitoringApps: [
                        {
                            id: 'monitoring_server',
                            name: 'Server Monitor',
                            description: 'Infrastructure Health',
                            icon: 'üñ•Ô∏è',
                            url: 'http://192.168.2.137:8080/monitoring_server/home'
                        },
                        {
                            id: 'monitoring_datasets',
                            name: 'Dataset Monitor',
                            description: 'Data Pipeline Status',
                            icon: 'üìä',
                            url: 'http://192.168.2.137:8080/monitoring_datasets/'
                        },
                        {
                            id: 'process_monitoring',
                            name: 'Process Monitor',
                            description: 'Service Health Check',
                            icon: '‚öôÔ∏è',
                            url: 'http://192.168.2.137:8080/process_monitoring/'
                        },
                        {
                            id: 'monitoring_sentinel',
                            name: 'Sentinel Monitor',
                            description: 'Satellite Tracking',
                            icon: 'üõ∞Ô∏è',
                            url: 'http://192.168.2.137:8080/monitoring_sentinel/'
                        },
                        {
                            id: 'ridam_dataset_publisher',
                            name: 'Dataset Explorer',
                            description: 'Browse & Search Data',
                            icon: 'üóÇÔ∏è',
                            url: 'http://192.168.2.137:8080/ridam_dataset_publisher/'
                        },
                        {
                            id: 'ridal_storage_pools',
                            name: 'Ridam Pool Monitoring',
                            description: 'Browse & Search Data',
                            icon: 'üóÑÔ∏è',
                            url: 'http://192.168.2.137:8080/pool_storage_monitoring/'
                        }
                    ],
                    dataApps: [
                        {
                            id: 'ridam_registration',
                            name: 'RIDAM Registry',
                            description: 'Data Registration',
                            icon: 'üìù',
                            url: 'http://192.168.2.137:8080/ridam_registration/'
                        }
                    ],
                    toolsApps: [
                        {
                            id: 'team_analytics',
                            name: 'Team Analytics',
                            description: 'Performance Metrics',
                            icon: 'üë•',
                            url: 'http://192.168.2.137:8080/taskboard/dashboard/'
                        }
                    ]
                };
            },
            computed: {
                allApplications() {
                    return [...this.monitoringApps, ...this.dataApps, ...this.toolsApps];
                },
                totalAlerts() {
                    return this.datasetAlerts.length + this.serverAlerts.length + this.processAlerts.length + this.storageAlerts.length;
                },
                isPanelCollapsed() {
                    return this.alertPanelCollapsedUp || this.alertPanelCollapsedLeft;
                },
                allSectionsCollapsed() {
                    return this.datasetSectionCollapsed && this.serverSectionCollapsed && this.processSectionCollapsed && this.storageSectionCollapsed;
                },
                // ‚ú® ALERT BREAKDOWN FOR HOME PAGE
                criticalAlerts() {
                    return this.datasetAlerts.filter(a => a.type === 'alert' || a.type === 'offline').length +
                           this.serverAlerts.filter(a => a.type === 'offline' || a.type === 'failed').length +
                           this.processAlerts.filter(a => a.type === 'failed' || a.type === 'offline').length +
                           this.storageAlerts.filter(a => a.type === 'alert').length;
                },
                warningAlerts() {
                    return this.datasetAlerts.filter(a => a.type === 'warning').length +
                           this.serverAlerts.filter(a => a.type === 'memory' || a.type === 'cpu' || a.type === 'storage').length +
                           this.processAlerts.filter(a => a.type === 'memory' || a.type === 'cpu' || a.type === 'storage').length +
                           this.storageAlerts.filter(a => a.type === 'warning').length;
                },
                infoAlerts() {
                    return this.storageAlerts.filter(a => a.type === 'info').length;
                }
            },
            methods: {
                toggleSidebar() {
                    this.sidebarCollapsed = !this.sidebarCollapsed;
                },
                navigateTo(page) {
                    this.currentPage = page;
                    if (page === 'home') {
                        this.currentAppUrl = '';
                    }
                },
                setActive(appId) {
                    this.isLoading = true;
                    this.currentPage = appId;
                    const app = this.allApplications.find(a => a.id === appId);
                    if (app) {
                        this.currentAppUrl = app.url;
                    }
                },
                onIframeLoad() {
                    setTimeout(() => {
                        this.isLoading = false;
                    }, 500);
                },
                handleThemeChange() {
                    if (this.currentTheme === 'auto') {
                        this.autoThemeEnabled = true;
                        this.applyAutoTheme();
                    } else {
                        this.autoThemeEnabled = false;
                        document.body.className = this.currentTheme;
                    }
                },
                applyAutoTheme() {
                    const hour = new Date().getHours();
                    let themeClass = '';

                    if (hour >= 5 && hour < 12) {
                        themeClass = 'theme-auto-morning';
                    } else if (hour >= 12 && hour < 17) {
                        themeClass = 'theme-auto-afternoon';
                    } else if (hour >= 17 && hour < 21) {
                        themeClass = 'theme-auto-evening';
                    } else {
                        themeClass = 'theme-auto-night';
                    }

                    document.body.className = themeClass;
                },
                toggleDatasetSection() {
                    this.datasetSectionCollapsed = !this.datasetSectionCollapsed;
                },
                toggleServerSection() {
                    this.serverSectionCollapsed = !this.serverSectionCollapsed;
                },
                toggleProcessSection() {
                    this.processSectionCollapsed = !this.processSectionCollapsed;
                },
                toggleStorageSection() {
                    this.storageSectionCollapsed = !this.storageSectionCollapsed;
                },
                collapseAllSections() {
                    if (this.allSectionsCollapsed) {
                        this.datasetSectionCollapsed = false;
                        this.serverSectionCollapsed = false;
                        this.processSectionCollapsed = false;
                        this.storageSectionCollapsed = false;
                    } else {
                        this.datasetSectionCollapsed = true;
                        this.serverSectionCollapsed = true;
                        this.processSectionCollapsed = true;
                        this.storageSectionCollapsed = true;
                    }
                },
                expandAlertPanel() {
                    this.alertPanelCollapsedUp = false;
                    this.alertPanelCollapsedLeft = false;
                },
                getTimeAgo(lastModifiedStr) {
                    try {
                        const lastModified = new Date(lastModifiedStr);
                        const now = new Date();
                        const diffMs = now - lastModified;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMins / 60);
                        const diffDays = Math.floor(diffHours / 24);

                        if (diffDays > 0) {
                            return `${diffDays}d ago`;
                        } else if (diffHours > 0) {
                            return `${diffHours}h ago`;
                        } else if (diffMins > 0) {
                            return `${diffMins}m ago`;
                        } else {
                            return 'Just now';
                        }
                    } catch (error) {
                        return 'Unknown';
                    }
                },
                checkBreakTime() {
                    const now = new Date();
                    const hour = now.getHours();
                    const minute = now.getMinutes();
                    const timeKey = `${hour}:${minute}`;

                    if (this.shownBreakTimes.has(timeKey)) {
                        return;
                    }

                    let breakInfo = null;

                    if (hour === 10 && minute === 30) {
                        breakInfo = {
                            icon: '‚òï',
                            title: 'Morning Tea Break!',
                            message: 'Time to refresh! Grab a cup of tea and enjoy a short break üçµ'
                        };
                    } else if (hour === 12 && minute === 30) {
                        breakInfo = {
                            icon: 'üçΩÔ∏è',
                            title: 'Lunch Time!',
                            message: 'Take a break and enjoy your delicious lunch! üçõ'
                        };
                    } else if (hour === 15 && minute === 0) {
                        breakInfo = {
                            icon: '‚òï',
                            title: 'Afternoon Tea Break!',
                            message: 'Time for some energy! Enjoy your tea and snacks üç™'
                        };
                    } else if (hour === 17 && minute === 30) {
                        breakInfo = {
                            icon: 'üè†',
                            title: 'Office Time is Over!',
                            message: 'Great work today! Time to head home and relax üéâ'
                        };
                    }

                    if (breakInfo) {
                        this.breakNotification = breakInfo;
                        this.showBreakNotification = true;
                        this.shownBreakTimes.add(timeKey);
                        this.breakAutoCloseSeconds = 30;
                        
                        this.breakAutoCloseInterval = setInterval(() => {
                            this.breakAutoCloseSeconds--;
                            if (this.breakAutoCloseSeconds <= 0) {
                                this.closeBreakNotification();
                            }
                        }, 1000);
                    }
                },
                closeBreakNotification() {
                    this.showBreakNotification = false;
                    if (this.breakAutoCloseInterval) {
                        clearInterval(this.breakAutoCloseInterval);
                        this.breakAutoCloseInterval = null;
                    }
                },
                updateTime() {
                    const now = new Date();
                    const options = {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    };
                    this.currentTime = now.toLocaleString('en-IN', options);

                    if (this.autoThemeEnabled) {
                        this.applyAutoTheme();
                    }

                    if (now.getSeconds() === 0) {
                        this.checkBreakTime();
                    }
                },
                async manualRefresh() {
                    this.isRefreshing = true;
                    await this.fetchNonStorageAlerts(); // Fast alerts
                    await this.fetchStorageAlerts(); // Storage alerts
                    setTimeout(() => {
                        this.isRefreshing = false;
                    }, 1000);
                },
                fetchWithTimeout(url, timeout = 30000) {
                    return Promise.race([
                        fetch(url),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Request timeout')), timeout)
                        )
                    ]);
                },
                
                // ‚ú® FETCH NON-STORAGE ALERTS (Runs every 1 minute)
                async fetchNonStorageAlerts() {
                    try {
                        const [datasetResult, serverResult, processResult] = await Promise.allSettled([
                            this.fetchWithTimeout('http://192.168.2.137:8080/monitoring_datasets//api/get_status_counts', 30000)
                                .then(res => res.json())
                                .catch(error => ({ error: true, message: error.message })),
                            
                            this.fetchWithTimeout('http://192.168.2.137:8080/monitoring_server/api/alerts', 30000)
                                .then(res => res.json())
                                .catch(error => ({ error: true, message: error.message })),
                            
                            this.fetchWithTimeout('http://192.168.2.137:8080/process_monitoring/get-alerts', 30000)
                                .then(res => res.json())
                                .catch(error => ({ error: true, message: error.message }))
                        ]);

                        // Process Dataset
                        const datasetData = datasetResult.status === 'fulfilled' ? datasetResult.value : null;
                        if (datasetData && datasetData.error) {
                            this.datasetAlerts = [{
                                type: 'API-ERROR',
                                message: datasetData.message === 'Request timeout' ? 
                                    'Dataset API timeout (>30s)' : 'Dataset API not reachable',
                                server: 'Dataset Monitoring'
                            }];
                        } else if (datasetData) {
                            const tempDatasetAlerts = [];
                            if (datasetData.alert > 0) {
                                tempDatasetAlerts.push({
                                    type: 'alert',
                                    message: `${datasetData.alert} dataset(s) in critical state`,
                                    server: 'Dataset Monitoring'
                                });
                            }
                            if (datasetData.warning > 0) {
                                tempDatasetAlerts.push({
                                    type: 'warning',
                                    message: `${datasetData.warning} dataset(s) showing warnings`,
                                    server: 'Dataset Monitoring'
                                });
                            }
                            if (datasetData.offline > 0) {
                                tempDatasetAlerts.push({
                                    type: 'offline',
                                    message: `${datasetData.offline} dataset(s) are offline`,
                                    server: 'Dataset Monitoring'
                                });
                            }
                            this.datasetAlerts = tempDatasetAlerts.filter(alert =>
                                !this.clearedAlerts.has(this.getAlertKey('dataset', alert))
                            );
                        }

                        // Process Server
                        const serverData = serverResult.status === 'fulfilled' ? serverResult.value : null;
                        if (serverData && serverData.error) {
                            this.serverAlerts = [{
                                type: 'API-ERROR',
                                message: serverData.message === 'Request timeout' ? 
                                    'Server API timeout (>30s)' : 'Server API not reachable',
                                server: 'Server Monitoring'
                            }];
                        } else if (serverData && serverData.alerts) {
                            this.serverAlerts = serverData.alerts.filter(alert =>
                                !this.clearedAlerts.has(this.getAlertKey('server', alert))
                            ).map(alert => {
                                if (!alert.type) {
                                    if (alert.message.toLowerCase().includes('memory')) alert.type = 'memory';
                                    else if (alert.message.toLowerCase().includes('cpu')) alert.type = 'cpu';
                                    else if (alert.message.toLowerCase().includes('storage') || alert.message.toLowerCase().includes('disk')) alert.type = 'storage';
                                    else if (alert.message.toLowerCase().includes('offline')) alert.type = 'offline';
                                    else alert.type = 'failed';
                                }
                                return alert;
                            });
                            if (serverData.total_servers) this.totalServers = serverData.total_servers;
                        }

                        // Process Process
                        const processData = processResult.status === 'fulfilled' ? processResult.value : null;
                        if (processData && processData.error) {
                            this.processAlerts = [{
                                type: 'API-ERROR',
                                message: processData.message === 'Request timeout' ? 
                                    'Process API timeout (>30s)' : 'Process API not reachable',
                                server: 'Process Monitoring'
                            }];
                        } else if (processData && processData.data && processData.data.alerts) {
                            this.processAlerts = processData.data.alerts.filter(alert =>
                                !this.clearedAlerts.has(this.getAlertKey('process', alert))
                            ).map(alert => {
                                if (!alert.type) {
                                    if (alert.message.toLowerCase().includes('memory')) alert.type = 'memory';
                                    else if (alert.message.toLowerCase().includes('cpu')) alert.type = 'cpu';
                                    else if (alert.message.toLowerCase().includes('storage') || alert.message.toLowerCase().includes('disk')) alert.type = 'storage';
                                    else if (alert.message.toLowerCase().includes('failed')) alert.type = 'failed';
                                    else alert.type = 'offline';
                                }
                                return alert;
                            });
                            this.lastUpdated = processData.last_updated_time || '';
                            if (processData.data.total_services) this.totalServices = processData.data.total_services;
                        }

                    } catch (error) {
                        console.error('Error fetching non-storage alerts:', error);
                    }
                },

                // ‚ú® FETCH STORAGE ALERTS (Runs every 2 hours)
                async fetchStorageAlerts() {
                    try {
                        console.log('üóÑÔ∏è Fetching Storage Pool Alerts (runs every 2 hours)...');
                        
                        const [scannerResult, storageResult] = await Promise.allSettled([
                            this.fetchWithTimeout('http://192.168.2.137:8080/storage_monitoring_api/scanner_stats', 30000)
                                .then(res => res.json())
                                .catch(error => ({ error: true, message: error.message })),
                            
                            this.fetchWithTimeout('http://192.168.2.137:8080/storage_monitoring_api/summary?summary_type=pools_only', 30000)
                                .then(res => res.json())
                                .catch(error => ({ error: true, message: error.message }))
                        ]);

                        // Process Scanner Stats
                        const scannerStats = scannerResult.status === 'fulfilled' ? scannerResult.value : null;
                        if (scannerStats && !scannerStats.error && scannerStats.last_modified) {
                            this.storageLastModified = scannerStats.last_modified;
                            console.log('‚úÖ Storage last modified updated:', this.storageLastModified);
                        }

                        // Process Storage
                        const storageData = storageResult.status === 'fulfilled' ? storageResult.value : null;
                        if (storageData && storageData.error) {
                            this.storageAlerts = [{
                                type: 'API-ERROR',
                                message: storageData.message === 'Request timeout' ? 
                                    'Storage API timeout (>30s)' : 'Storage API not reachable',
                                server: 'Storage Monitoring',
                                lastScanTime: 'Unknown'
                            }];
                        } else if (storageData && storageData.pools) {
                            const tempStorageAlerts = [];
                            
                            Object.keys(storageData.pools).forEach(poolName => {
                                const pool = storageData.pools[poolName];
                                
                                if (pool.master && pool.master.stats) {
                                    const stats = pool.master.stats;
                                    const usedSize = stats.size;
                                    const totalSize = stats.total_size;
                                    const usagePercent = (usedSize / totalSize) * 100;
                                    const remainingSize = totalSize - usedSize;
                                    
                                    const lastScanTime = this.storageLastModified ? 
                                        `Last scan: ${this.getTimeAgo(this.storageLastModified)}` : 
                                        'Scan time unknown';
                                    
                                    if (usagePercent >= 90) {
                                        tempStorageAlerts.push({
                                            type: 'alert',
                                            message: `${poolName} is ${usagePercent.toFixed(1)}% full (${usedSize.toFixed(2)} GB / ${totalSize} GB) - Critical!`,
                                            server: `Storage Pool - ${poolName.toUpperCase()}`,
                                            usage: usagePercent.toFixed(1),
                                            remaining: remainingSize.toFixed(2),
                                            prediction: stats.prediction.predicted_fill_date,
                                            lastScanTime: lastScanTime
                                        });
                                    } else if (usagePercent >= 75) {
                                        tempStorageAlerts.push({
                                            type: 'warning',
                                            message: `${poolName} is ${usagePercent.toFixed(1)}% full (${usedSize.toFixed(2)} GB / ${totalSize} GB) - Warning!`,
                                            server: `Storage Pool - ${poolName.toUpperCase()}`,
                                            usage: usagePercent.toFixed(1),
                                            remaining: remainingSize.toFixed(2),
                                            prediction: stats.prediction.predicted_fill_date,
                                            lastScanTime: lastScanTime
                                        });
                                    } else if (usagePercent >= 60) {
                                        tempStorageAlerts.push({
                                            type: 'info',
                                            message: `${poolName} is ${usagePercent.toFixed(1)}% full (${usedSize.toFixed(2)} GB / ${totalSize} GB) - Healthy`,
                                            server: `Storage Pool - ${poolName.toUpperCase()}`,
                                            usage: usagePercent.toFixed(1),
                                            remaining: remainingSize.toFixed(2),
                                            prediction: stats.prediction.predicted_fill_date,
                                            lastScanTime: lastScanTime
                                        });
                                    }
                                }
                            });

                            this.storageAlerts = tempStorageAlerts.filter(alert =>
                                !this.clearedAlerts.has(this.getAlertKey('storage', alert))
                            );

                            this.storageAlerts.sort((a, b) => {
                                const order = { 'alert': 1, 'warning': 2, 'info': 3 };
                                return (order[a.type] || 999) - (order[b.type] || 999);
                            });
                        }

                        this.lastStorageFetch = new Date();
                        console.log('‚úÖ Storage fetch completed at:', this.lastStorageFetch.toLocaleTimeString());

                    } catch (error) {
                        console.error('Error fetching storage alerts:', error);
                    }
                },

                getAlertKey(type, alert) {
                    return `${type}-${alert.server}-${alert.type}-${alert.message}`;
                },
                removeAlert(type, index) {
                    const now = new Date();
                    const timeStr = now.toLocaleString('en-IN', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    if (type === 'dataset') {
                        const alert = this.datasetAlerts[index];
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('dataset', alert));
                        this.datasetAlerts.splice(index, 1);
                    } else if (type === 'server') {
                        const alert = this.serverAlerts[index];
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('server', alert));
                        this.serverAlerts.splice(index, 1);
                    } else if (type === 'process') {
                        const alert = this.processAlerts[index];
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('process', alert));
                        this.processAlerts.splice(index, 1);
                    } else if (type === 'storage') {
                        const alert = this.storageAlerts[index];
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('storage', alert));
                        this.storageAlerts.splice(index, 1);
                    }

                    if (this.alertHistory.length > 50) {
                        this.alertHistory = this.alertHistory.slice(0, 50);
                    }
                },
                clearAllAlerts() {
                    const now = new Date();
                    const timeStr = now.toLocaleString('en-IN', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    this.datasetAlerts.forEach(alert => {
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('dataset', alert));
                    });
                    this.serverAlerts.forEach(alert => {
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('server', alert));
                    });
                    this.processAlerts.forEach(alert => {
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('process', alert));
                    });
                    this.storageAlerts.forEach(alert => {
                        this.alertHistory.unshift({ ...alert, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey('storage', alert));
                    });

                    this.datasetAlerts = [];
                    this.serverAlerts = [];
                    this.processAlerts = [];
                    this.storageAlerts = [];

                    if (this.alertHistory.length > 50) {
                        this.alertHistory = this.alertHistory.slice(0, 50);
                    }
                },
                closeAlertPanel() {
                    this.alertPanelCollapsedUp = false;
                    this.alertPanelCollapsedLeft = true;
                }
            },
            watch: {
                currentTheme(newTheme) {
                    if (newTheme !== 'auto') {
                        document.body.className = newTheme;
                    }
                }
            },
            mounted() {
                document.body.className = 'theme-vedas';

                const now = new Date();
                const midnight = new Date(now);
                midnight.setHours(24, 0, 0, 0);
                const msUntilMidnight = midnight - now;
                
                setTimeout(() => {
                    this.shownBreakTimes.clear();
                    setInterval(() => {
                        this.shownBreakTimes.clear();
                    }, 24 * 60 * 60 * 1000);
                }, msUntilMidnight);

                this.updateTime();
                setInterval(this.updateTime, 1000);
                
                // ‚úÖ Fetch non-storage alerts immediately and every 1 minute
                this.fetchNonStorageAlerts();
                setInterval(this.fetchNonStorageAlerts, 60000); // 1 minute
                
                // ‚úÖ Fetch storage alerts immediately and every 2 hours
                this.fetchStorageAlerts();
                setInterval(this.fetchStorageAlerts, 7200000); // 2 hours

                setInterval(() => {
                    const monitoringApps = this.monitoringApps.filter(app =>
                        app.id !== 'monitoring_sentinel'
                    );

                    if (monitoringApps.length === 0) return;

                    if (this.currentPage !== 'home') {
                        let currentIndex = monitoringApps.findIndex(app => app.id === this.currentPage);

                        if (currentIndex === -1) {
                            this.setActive(monitoringApps[0].id);
                        } else {
                            let nextIndex = (currentIndex + 1) % monitoringApps.length;
                            this.setActive(monitoringApps[nextIndex].id);
                        }
                    } else {
                        this.setActive(monitoringApps[0].id);
                    }
                }, 600000);
            }
        }).mount('#app');
    </script>

















<div class="stats-container">
    <div class="stat-card" :class="{ 'alert-pulse': criticalAlerts > 0 }">
        <div class="stat-icon">üî¥</div>
        <div class="stat-value">{{ criticalAlerts }}</div>
        <div class="stat-label">Critical Alerts</div>
    </div>
    <div class="stat-card" :class="{ 'warning-pulse': warningAlerts > 0 }">
        <div class="stat-icon">‚ö†Ô∏è</div>
        <div class="stat-value">{{ warningAlerts }}</div>
        <div class="stat-label">Warning Alerts</div>
    </div>
    <div class="stat-card">
        <div class="stat-icon">üñ•Ô∏è</div>
        <div class="stat-value">{{ totalServers }}</div>
        <div class="stat-label">Total Servers</div>
    </div>
    <div class="stat-card">
        <div class="stat-icon">‚öôÔ∏è</div>
        <div class="stat-value">{{ totalServices }}</div>
        <div class="stat-label">Active Services</div>
    </div>
    <div class="stat-card">
        <div class="stat-icon">üìä</div>
        <div class="stat-value">{{ allApplications.length }}</div>
        <div class="stat-label">Applications</div>
    </div>
    <div class="stat-card">
        <div class="stat-icon">üíæ</div>
        <div class="stat-value">{{ storageAlerts.length }}</div>
        <div class="stat-label">Storage Pools</div>
    </div>
</div>



.alert-pulse {
    animation: alertPulse 2s infinite !important;
    border-color: #ef4444 !important;
}

.warning-pulse {
    animation: warningPulse 2s infinite !important;
    border-color: #f59e0b !important;
}

@keyframes alertPulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
    }
    50% {
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
    }
}

@keyframes warningPulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
    }
    50% {
        box-shadow: 0 0 40px rgba(245, 158, 11, 0.6);
    }
}


