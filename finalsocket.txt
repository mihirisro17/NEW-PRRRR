<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VEDAS Management Information System</title>
    <script src="vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <style>
        /* ... (Keep all your existing CSS styles - they're fine) ... */
        
        /* ===== CRITICAL FIX FOR IFRAME ===== */
        .main-content {
            margin-left: 320px;
            margin-top: 80px;
            width: calc(100% - 320px);
            height: calc(100vh - 80px);
            padding: 0;  /* âœ… REMOVED PADDING FOR IFRAME PAGES */
            overflow-y: auto;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-color);
            position: relative;
        }

        .main-content.expanded {
            margin-left: 0;
            width: 100%;
        }

        /* âœ… ADD PADDING ONLY TO HOME PAGE */
        .home-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            position: relative;
            padding: 45px;  /* âœ… PADDING HERE INSTEAD */
            padding-bottom: 80px;
        }

        .app-frame {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;  /* âœ… REMOVE BORDER RADIUS FOR FULL SCREEN */
            box-shadow: none;  /* âœ… REMOVE SHADOW */
        }
    </style>
</head>

<body>
    <!-- ... (Keep all your existing HTML - it's fine) ... -->

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // ... (Keep all your existing data properties) ...
                    
                    // DYNAMIC ALERT STORAGE
                    alertsByCategory: {},
                    sectionCollapsed: {},
                    categoryMetadata: {},
                    
                    clearedAlerts: new Set(),
                    lastUpdated: 'Initializing...',
                    
                    // Socket.IO
                    socket: null,
                    socketConnected: false,
                    
                    // ... (rest of your data properties) ...
                };
            },
            computed: {
                // ... (Keep all your existing computed properties) ...
            },
            methods: {
                // ============= DYNAMIC CATEGORY MANAGEMENT =============
                ensureCategory(category) {
                    if (!this.alertsByCategory[category]) {
                        Vue.set(this.alertsByCategory, category, []);
                        Vue.set(this.sectionCollapsed, category, false);
                        
                        if (!this.categoryMetadata[category]) {
                            Vue.set(this.categoryMetadata, category, this.getDefaultCategoryMetadata(category));
                        }
                    }
                },

                getDefaultCategoryMetadata(category) {
                    const defaults = {
                        'server': { icon: 'ðŸ–¥ï¸', name: 'Server Alerts', color: '#ef4444' },
                        'dataset': { icon: 'ðŸ“Š', name: 'Dataset Alerts', color: '#6366f1' },
                        'process': { icon: 'âš™ï¸', name: 'Process Alerts', color: '#f59e0b' },
                        'storage': { icon: 'ðŸ’¾', name: 'Storage Alerts', color: '#3b82f6' },
                        'network': { icon: 'ðŸŒ', name: 'Network Alerts', color: '#10b981' },
                        'database': { icon: 'ðŸ—„ï¸', name: 'Database Alerts', color: '#8b5cf6' },
                        'application': { icon: 'ðŸ“±', name: 'Application Alerts', color: '#ec4899' }
                    };
                    
                    return defaults[category] || {
                        icon: 'ðŸ””',
                        name: `${this.capitalizeFirst(category)} Alerts`,
                        color: '#6366f1'
                    };
                },

                capitalizeFirst(str) {
                    return str.charAt(0).toUpperCase() + str.slice(1);
                },

                getCategoryIcon(category) {
                    return this.categoryMetadata[category]?.icon || 'ðŸ””';
                },

                getCategoryName(category) {
                    return this.categoryMetadata[category]?.name || this.capitalizeFirst(category);
                },

                getCategoryAlerts(category) {
                    return this.alertsByCategory[category] || [];
                },

                getCategoryCount(category) {
                    return this.getCategoryAlerts(category).length;
                },

                // ============= SOCKET.IO INITIALIZATION (FIXED) =============
                initializeSocket() {
                    console.log('ðŸ”Œ Initializing Socket.IO connection...');
                    console.log('ðŸ“ Connecting to: http://192.168.2.137:8080');
                    
                    this.socket = io('http://192.168.2.137:8080', {
                        transports: ['websocket', 'polling'],
                        reconnection: true,
                        reconnectionDelay: 1000,
                        reconnectionAttempts: 10,
                        timeout: 20000
                    });

                    // âœ… Connection Events (REGISTERED OUTSIDE - CORRECT!)
                    this.socket.on('connect', () => {
                        console.log('âœ… Socket.IO Connected - ID:', this.socket.id);
                        this.socketConnected = true;
                        this.lastUpdated = `Connected at ${this.formatTime(new Date())}`;
                    });

                    this.socket.on('disconnect', (reason) => {
                        console.log('âŒ Socket.IO Disconnected - Reason:', reason);
                        this.socketConnected = false;
                        this.lastUpdated = `Disconnected: ${reason}`;
                    });

                    this.socket.on('connect_error', (error) => {
                        console.error('ðŸ”¥ Socket.IO Connection Error:', error.message);
                        this.socketConnected = false;
                        this.lastUpdated = 'Connection Error';
                    });

                    // ===== UNIVERSAL ALERT HANDLER (FIXED WITH BETTER LOGS) =====
                    this.socket.on('alert', (data) => {
                        console.log('ðŸ”” [ALERT EVENT] Raw data:', JSON.stringify(data, null, 2));
                        this.handleDynamicAlert(data);
                    });

                    // Backward compatibility
                    this.socket.on('new_alert', (data) => {
                        console.log('ðŸ”” [NEW_ALERT EVENT] Raw data:', data);
                        this.handleDynamicAlert(data);
                    });
                    
                    this.socket.on('server_alert', (data) => {
                        console.log('ðŸ–¥ï¸ [SERVER_ALERT EVENT] Raw data:', data);
                        this.handleDynamicAlert({ ...data, category: 'server' });
                    });
                    
                    this.socket.on('dataset_alert', (data) => {
                        console.log('ðŸ“Š [DATASET_ALERT EVENT] Raw data:', data);
                        this.handleDynamicAlert({ ...data, category: 'dataset' });
                    });
                    
                    this.socket.on('process_alert', (data) => {
                        console.log('âš™ï¸ [PROCESS_ALERT EVENT] Raw data:', data);
                        this.handleDynamicAlert({ ...data, category: 'process' });
                    });
                    
                    this.socket.on('storage_alert', (data) => {
                        console.log('ðŸ’¾ [STORAGE_ALERT EVENT] Raw data:', data);
                        this.handleDynamicAlert({ ...data, category: 'storage' });
                    });

                    // Alert cleared
                    this.socket.on('alert_cleared', (data) => {
                        console.log('âœ… [ALERT_CLEARED EVENT]:', data);
                        this.handleAlertCleared(data);
                    });

                    // Clear alerts
                    this.socket.on('clear_alerts', (data) => {
                        console.log('ðŸ—‘ï¸ [CLEAR_ALERTS EVENT]:', data);
                        if (data.category) {
                            this.clearAlertsByCategory(data.category);
                        } else {
                            this.clearAllAlerts();
                        }
                    });

                    // Stats update
                    this.socket.on('update_stats', (data) => {
                        console.log('ðŸ“Š [UPDATE_STATS EVENT]:', data);
                        if (data.totalServers !== undefined) this.totalServers = data.totalServers;
                        if (data.totalServices !== undefined) this.totalServices = data.totalServices;
                    });

                    // Category metadata
                    this.socket.on('category_metadata', (data) => {
                        console.log('ðŸ“‹ [CATEGORY_METADATA EVENT]:', data);
                        if (data.category && data.metadata) {
                            Vue.set(this.categoryMetadata, data.category, data.metadata);
                        }
                    });

                    // Initial alerts load
                    this.socket.on('initial_alerts', (data) => {
                        console.log('ðŸ“¦ [INITIAL_ALERTS EVENT]:', data);
                        Object.keys(data).forEach(category => {
                            this.ensureCategory(category);
                            Vue.set(this.alertsByCategory, category, data[category] || []);
                        });
                        this.lastUpdated = this.formatTime(new Date());
                    });

                    console.log('âœ… All Socket.IO event listeners registered');
                },

                // ============= DYNAMIC ALERT HANDLER (FIXED WITH VUE REACTIVITY) =============
                handleDynamicAlert(data) {
                    console.log('ðŸ”” [handleDynamicAlert] Processing:', data);
                    
                    // Extract category
                    const category = (data.category || data.source || 'general').toLowerCase();
                    console.log(`ðŸ“‚ Category identified: ${category}`);

                    // Create alert object
                    const alert = {
                        type: data.type || 'alert',
                        message: data.message || 'Unknown alert',
                        server: data.server || 'Unknown',
                        source: data.source || category,
                        timestamp: data.timestamp || new Date().toISOString(),
                        metadata: data.metadata || {},
                        ...data
                    };

                    // Check if already cleared
                    const key = this.getAlertKey(category, alert);
                    if (this.clearedAlerts.has(key)) {
                        console.log('â­ï¸ Alert already cleared, skipping:', key);
                        return;
                    }

                    // Ensure category exists
                    this.ensureCategory(category);
                    console.log(`âœ… Category "${category}" ready, current alerts:`, this.alertsByCategory[category].length);

                    // Check for duplicates
                    const exists = this.alertsByCategory[category].some(a =>
                        a.type === alert.type &&
                        a.message === alert.message &&
                        a.server === alert.server
                    );

                    if (!exists) {
                        // âœ… USE VUE.SET FOR REACTIVITY
                        this.alertsByCategory[category].unshift(alert);
                        this.$forceUpdate();  // Force Vue to re-render
                        console.log(`âœ… Alert added to "${category}". Total:`, this.alertsByCategory[category].length);
                        console.log(`ðŸ”¢ Total alerts across all categories:`, this.totalAlerts);
                    } else {
                        console.log('âš ï¸ Duplicate alert detected, skipping');
                    }

                    this.lastUpdated = this.formatTime(new Date());
                },

                // ============= REST OF YOUR METHODS (Keep as is) =============
                handleAlertCleared(data) {
                    const category = data.category;
                    if (!category || !this.alertsByCategory[category]) return;

                    const alertKey = this.getAlertKey(category, data.alert);
                    this.clearedAlerts.add(alertKey);
                    
                    this.alertsByCategory[category] = this.alertsByCategory[category].filter(a =>
                        this.getAlertKey(category, a) !== alertKey
                    );
                    
                    this.lastUpdated = this.formatTime(new Date());
                },

                getAlertKey(category, alert) {
                    return `${category}-${alert.server}-${alert.type}-${alert.message}`;
                },

                removeAlert(category, index) {
                    if (!this.alertsByCategory[category]) return;

                    const now = new Date();
                    const timeStr = now.toLocaleString('en-IN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                    
                    const alert = this.alertsByCategory[category][index];
                    if (!alert) return;

                    this.alertHistory.unshift({ ...alert, category, clearedAt: timeStr });
                    this.clearedAlerts.add(this.getAlertKey(category, alert));
                    
                    this.alertsByCategory[category].splice(index, 1);

                    if (this.socket && this.socketConnected) {
                        this.socket.emit('clear_alert', { category, alert });
                    }

                    if (this.alertHistory.length > 50) {
                        this.alertHistory = this.alertHistory.slice(0, 50);
                    }
                },

                clearAlertsByCategory(category) {
                    if (!this.alertsByCategory[category]) return;

                    const now = new Date();
                    const timeStr = now.toLocaleString('en-IN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                    
                    this.alertsByCategory[category].forEach(alert => {
                        this.alertHistory.unshift({ ...alert, category, clearedAt: timeStr });
                        this.clearedAlerts.add(this.getAlertKey(category, alert));
                    });

                    Vue.set(this.alertsByCategory, category, []);

                    if (this.socket && this.socketConnected) {
                        this.socket.emit('clear_alerts', { category });
                    }

                    if (this.alertHistory.length > 50) {
                        this.alertHistory = this.alertHistory.slice(0, 50);
                    }
                    
                    this.closeAlertModal();
                },

                clearAllAlerts() {
                    const now = new Date();
                    const timeStr = now.toLocaleString('en-IN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                    
                    Object.keys(this.alertsByCategory).forEach(category => {
                        this.alertsByCategory[category].forEach(alert => {
                            this.alertHistory.unshift({ ...alert, category, clearedAt: timeStr });
                            this.clearedAlerts.add(this.getAlertKey(category, alert));
                        });
                        Vue.set(this.alertsByCategory, category, []);
                    });

                    if (this.socket && this.socketConnected) {
                        this.socket.emit('clear_all_alerts');
                    }

                    if (this.alertHistory.length > 50) {
                        this.alertHistory = this.alertHistory.slice(0, 50);
                    }
                },

                manualRefresh() {
                    this.isRefreshing = true;
                    
                    if (this.socket && this.socketConnected) {
                        this.socket.emit('request_alerts');
                        console.log('ðŸ”„ Requested latest alerts from server');
                    } else {
                        console.warn('âš ï¸ Socket not connected, cannot refresh');
                    }
                    
                    setTimeout(() => {
                        this.isRefreshing = false;
                    }, 1000);
                },

                // ... (Keep all your other methods: UI controls, theme, utilities, etc.) ...
                
                formatTime(date) {
                    const d = new Date(date);
                    return d.toLocaleString('en-IN', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                },

                // ... (Rest of your methods) ...
            },

            watch: {
                currentTheme(newTheme) {
                    if (newTheme !== 'auto') {
                        document.body.className = newTheme;
                    }
                }
            },

            mounted() {
                console.log('ðŸš€ Vue app mounted');
                document.body.className = 'theme-vedas';
                
                // Initialize Socket.IO
                this.initializeSocket();

                // Test alert after 5 seconds (for debugging)
                setTimeout(() => {
                    console.log('ðŸ§ª Testing manual alert injection...');
                    this.handleDynamicAlert({
                        category: 'test',
                        type: 'info',
                        message: 'Test alert - Vue is working!',
                        server: 'Frontend Test',
                        timestamp: new Date().toISOString()
                    });
                }, 5000);

                // ... (Keep all your other mounted code) ...
                
                this.updateTime();
                setInterval(this.updateTime, 1000);
            }
        }).mount('#app');
    </script>

</body>

</html>
